*   What are various Spring MVC annotations ?

>>  Below is the complete list of Spring MVC annotations:

        (1)  @Controller  
        (2)  @RestController
        (3)  @RequestMapping  
        (4)  @GetMapping  
        (5)  @PostMapping  
        (6)  @PutMapping  
        (7)  @PatchMapping  
        (8)  @DeleteMapping  
        (9)  @RequestHeader  
        (10) @RequestParam 
        (11) @CookieValue  
        (12) @PathVariable 
        (13) @RequestBody 
        (14) @RequestPart
        (15) @RequestAttribute  
        (16) @SessionAttribute 
        (17) @SessionAttributes 
        (18) @ModelAttribute 
        (19) @ResponseBody
        (20) @ResponseStatus
        (21) @ExceptionHandler  
        (22) @ControllerAdvice  
        (23) @RestControllerAdvice  
        (24) @RequestScope  
        (25) @SessionScope  
        (26) @ApplicationScope  
        (27) @Valid  
        (28) @Validated 
        (29) @EnableWebMvc 
        (20) @CrossOrigin
        (31) @MatrixVariable     
        (32) @InitBinder  
        (33) @ResponseBodyEmitter  
        (34) @StreamingResponseBody  
        (35) @PageableDefault  
        (36) @SortDefault  

________________________________________________________________________________________________________________________

*   What is the difference between @RestController and @Controller ?

>>  (1) Purpose:

        - @Controller used for creating traditional MVC applications where the methods return views (HTML, JSP, Thymeleaf, etc.).

        - @RestController specifically used for creating RESTful web services where methods return data in formats like 
          JSON or XML.

    (2) Response Type:

        - @Controller: By default, methods return views (HTML files) and need @ResponseBody to send data like JSON or XML.

        - @RestController: Automatically serializes return objects into JSON or XML and sends them as the HTTP response body (no need for @ResponseBody).


    (3) Usage:

        - @Controller: Suitable for applications where both dynamic web pages and REST endpoints are needed.

        - @RestController: Used when the application is purely focused on providing an API (typically for web services or mobile apps).

________________________________________________________________________________________________________________________

*   What is the use of @RequestMapping and how does it differ from the newer mapping annotations ?

>>  @RequestMapping is a core annotation in Spring MVC used to map web requests to specific controller methods or classes.

    It can handle all HTTP methods (GET, POST, PUT, DELETE, etc.) using its method attribute.

    It can be used at both class level and method level.

    Example:

        ```
            @RequestMapping(value = "/users", method = RequestMethod.GET)
            public List<User> getUsers() {
                return userService.getAllUsers();
            }
        ```

________________________________________________________________________________________________________________________

*   How do @GetMapping, @PostMapping, @PutMapping, @PatchMapping and @DeleteMapping work ?

>>  These annotations are specialized versions of @RequestMapping for specific HTTP methods, introduced in Spring 4.3, 
    and are used to map specific HTTP methods to handler methods in a REST controller.

    (1) @GetMapping:

        - Maps HTTP GET requests which is used to retrieve data from the server.

            ```
                @GetMapping("/users")
                public List<User> getAllUsers() {
                    return userService.getAllUsers();
                }
            ```

    (2) @PostMapping:
        
        - Maps HTTP POST requests which is used to create a new resource.

            ```
                @PostMapping("/users")
                public User createUser(@RequestBody User user) {
                    return userService.saveUser(user);
                }
            ```

    (3) @PutMapping:
        
        - Maps HTTP PUT requests which is used to fully update an existing resource.

            ```
                @PutMapping("/users/{id}")
                public User updateUser(@PathVariable Long id, @RequestBody User user) {
                    return userService.updateUser(id, user);
                }
            ```

    (4) @PatchMapping:

        - Maps HTTP PATCH requests which is used for partial updates of a resource — unlike @PutMapping which 
          expects full updates.

            ```
                @PatchMapping("/users/{id}")
                public User partiallyUpdateUser(@PathVariable Long id, @RequestBody User user) {
                    return userService.updateUser(id, user);
                }
            ```

    (5) @DeleteMapping:

        - Maps HTTP DELETE requests which is used to delete a resource.

            ```
                @DeleteMapping("/users/{id}")
                public void deleteUser(@PathVariable Long id) {
                    userService.deleteUser(id);
                }
            ```

________________________________________________________________________________________________________________________

*   What is the difference between RequestMethod, @RequestHeader, @RequestParam, @PathVariable, and @RequestBody ?

>>  (1) RequestMethod:

        - RequestMethod is an enum used within the @RequestMapping annotation to define HTTP methods like GET, POST, etc.

        Example:

            ```
                @RequestMapping(value = "/hello", method = RequestMethod.GET)
                public String sayHello() {
                    return "Hello!";
                }
            ```

    (2) @RequestHeader:

        - Used to map HTTP request headers to a method argument.

        Example:

            ```
                @GetMapping("/hello")
                public String hello(@RequestHeader("User-Agent") String userAgent) {
                    return "User-Agent: " + userAgent;
                }
            ```

    (3) @RequestParam:

        - Used to map query parameters from the URL to a method argument.

        Example:

            ```
                // URL: /greet?name=Joe

                @GetMapping("/greet")
                public String greet(@RequestParam String name) {
                    return "Hello " + name;
                }
            ```
                
    (4) @PathVariable:

        - Used to map values from URI path segments to a method argument.

        Example:

                ```
                    // URL: /users/10
                    @GetMapping("/users/{id}")
                    public User getUser(@PathVariable Long id) {
                        return userService.getUserById(id);
                    }
                ```
    (5) @RequestBody:

        - Binds the HTTP request body to a Java object.

        - Requires a JSON/XML body and automatically converts it using HttpMessageConverters.

        Example:

            ```
                // POST request with JSON body: { "name": "Joe", "age": 25 }
                @PostMapping("/users")
                public User createUser(@RequestBody User user) {
                    return userService.saveUser(user);
                }
            ```

________________________________________________________________________________________________________________________

*   How do you handle default values in @RequestParam ?

>>  When a request parameter is missing, @RequestParam can use a default value instead of throwing an error.

    Key Attributes of @RequestParam:
        
        (1) value: Name of the request parameter.

        (2) required: If true, throws error when missing. If false, allows absence.

        (3) defaultValue: Used when the parameter is not present.

    Example:

        - If '?name=' is absent in url then Spring will inject 'Guest' as a value of param 'name'  

        ```
            @GetMapping("/greet")
            public String greetUser(@RequestParam(defaultValue = "Guest") String name) {
                return "Hello, " + name;
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @RequestPart ?

>>  @RequestPart is used to extract specific parts from a multipart/form-data request, commonly used to handle file 
    uploads along with JSON objects in REST APIs.

    If JSON/XML objects are sent as a raw request body, then @RequestPart can extract it. In such case @RequestBody is used. 

    Example: 

        - 'file' is the binary part.

        - 'user' is a JSON object (Spring deserializes it using Jackson).

        ```
            @PostMapping("/upload")
            public ResponseEntity<String> upload(@RequestPart("file") MultipartFile file, @RequestPart("user") UserDTO user) {
            
                // process file and object
                return ResponseEntity.ok("Uploaded successfully");
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @CookieValue ?

>>  @CookieValue is used to extract a specific cookie value from the HTTP request and map it directly to a controller 
    method parameter.

    It’s similar to @RequestParam, but it pulls the data from a cookie instead of query parameters or form fields.

    Example:
        
        ```
            @GetMapping("/welcome")
            public String welcome(@CookieValue("username") String username) {
                return "Welcome " + username;
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @MatrixVariable ?

>>  Matrix variables are name-value pairs embedded in a URL path, separated by semicolons (;).

        ```
            http://amazon.com/products;color=red;size=medium
        ```
    @MatrixVariable is used to access this name-value pairs. 

    Example:

        ```
            @GetMapping("/products/")
            public ResponseEntity<String> getProducts(
                    @MatrixVariable(required = false, defaultValue = "all") String color,
                    @MatrixVariable(required = false) size) {
                // process
            }
        ```

    By default, Spring MVC strips semicolon content. To enable matrix variable support, you must configure:

        ```
            @Configuration
            public class WebConfig implements WebMvcConfigurer {
                @Override
                public void configurePathMatch(PathMatchConfigurer configurer) {
                    configurer.setUseMatrixVariables(true);
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @ResponseBody ?

>>  @ResponseBody tells Spring not to return a view, instead write the return value to the HTTP response body (JSON or XML).

    Commonly used with @Controller but not needed with @RestController, which includes it implicitly.

    Spring uses HTTP message converters (like Jackson) to convert Java objects to JSON/XML and writes them in the HTTP response.

    Example:

        - Without @ResponseBody, it would try to find a view named "Hello, World!".

        ```
            @Controller
            public class MyController {

                @ResponseBody
                @GetMapping("/hello")
                public String sayHello() {
                    return "Hello, World!";
                }
            }
        ```

________________________________________________________________________________________________________________________

*   How do you return custom HTTP status codes from a controller ?

>>  (1) Using ResponseEntity:

        - Most flexible way to return custom status codes, headers, and body.

            ```
                @GetMapping("/greet")
                public ResponseEntity<String> greet() {
                    return new ResponseEntity<>("Hello!", HttpStatus.ACCEPTED); // 202
                }
            ```
    (2) Using @ResponseStatus:

        - Used at method or exception class level to return fixed status.

            ```
                @ResponseStatus(HttpStatus.CREATED) // 201
                @PostMapping("/user")
                public void createUser(@RequestBody User user) {
                    // logic
                }
            ```

________________________________________________________________________________________________________________________

*   What are ResponseEntity and HttpStatus, and how are they used ?

>>  (1) ResponseEntity<?>:

        - It is a generic wrapper for HTTP response that includes:
            
            (a) Response body
            (b) HTTP status code
            (c) Optional headers

        Example:

            ```
                @GetMapping("/custom")
                public ResponseEntity<String> customResponse() {
                    HttpHeaders headers = new HttpHeaders();
                    headers.add("X-Custom-Header", "value");
                    return new ResponseEntity<>("Custom body", headers, HttpStatus.ACCEPTED);
                }
            ```

    (2) HttpStatus:

        - It is an enum provided by Spring that represents standard HTTP response status codes like:

            (a) HttpStatus.OK → 200
            (b) HttpStatus.CREATED → 201
            (c) HttpStatus.NOT_FOUND → 404
            (d) HttpStatus.INTERNAL_SERVER_ERROR → 500

________________________________________________________________________________________________________________________

*   What is the use of @RequestAttribute ?

>>  @RequestAttribute is used to map request attributes set on the server side (not by the client), typically by filters 
    or interceptors to the method parameters.

    It is used when data is pre-populated by filters, interceptors, or other internal logic and you need to access 
    it in a controller.
    
    Example:

        ```
            @GetMapping("/profile")
            public String getProfile(@RequestAttribute("userId") String userId) {
                return "User ID from attribute: " + userId;
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @SessionAttribute ?

>>  @SessionAttribute is used to map attributes from the HttpSession to a method parameter in a Spring controller.

    It allows access to server-side session data that was previously stored (e.g., after login).
    
    Example:

        - Assumes the user object was previously saved to the session which can be accessed using @SessionAttribute

        ```
            User user = new User("Joe");
            request.getSession().setAttribute("user", user);
        ```

        ```
            @GetMapping("/dashboard")
            public String dashboard(@SessionAttribute("user") User user) {
                return "Welcome, " + user.getName();
            }
        ```

________________________________________________________________________________________________________________________

*   What is the difference between @SessionAttribute and @SessionAttributes ?

>>  

________________________________________________________________________________________________________________________


*   What is the use of @ModelAttribute ?

>>  @ModelAttribute is used to bind form data or query parameters to a Java object.

    It supports application/x-www-form-urlencoded and multipart/form-data. 
    
    Example:

        ```
            public class User {
                private String name;
                private int age;
            }
        ```

        ```
            @PostMapping("/register")
            public String registerUser(@ModelAttribute User user) {
                // Spring binds form fields to 'user' object
                return "userRegistered";
            }
        ```

________________________________________________________________________________________________________________________

*   What is the difference between @ModelAttribute and @RequestBody ?

>>  @ModelAttribute binds form data or query parameters to Java objects. 
    
    @RequestBody binds JSON/XML request body to Java objects for REST APIs.
    
________________________________________________________________________________________________________________________

*   What is the purpose of @ExceptionHandler ?

>>  @ExceptionHandler is used to define custom methods to handle exceptions thrown by controller methods in a centralized 
    and clean way.

    It allows you to define custom responses when a specific exception is thrown during request processing.

    Example 
    
        (1) Controller Level:
        
            ```
                @RestController
                public class MyController {

                    @GetMapping("/divide")
                    public int divide(@RequestParam int a, @RequestParam int b) {
                        return a / b; // Might throw ArithmeticException
                    }

                    @ExceptionHandler(ArithmeticException.class)
                    public ResponseEntity<String> handleArithmetic(ArithmeticException ex) {
                        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Cannot divide by zero!");
                     }
                }
            ```
        (2) Global Exception Handling:
            
            ```
                @ControllerAdvice
                public class GlobalExceptionHandler {

                    @ExceptionHandler(ResourceNotFoundException.class)
                    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
                        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Resource not found");
                    }
                }
            ```

________________________________________________________________________________________________________________________

*   What is @ControllerAdvice and how is it used for global exception handling ?

>>  @ControllerAdvice is used to handle exceptions globally in a Spring Boot application by defining @ExceptionHandler 
    methods which is shared accross controllers.

    Example:

        ```
            @ControllerAdvice
            public class GlobalExceptionHandler {

                @ExceptionHandler(ResourceNotFoundException.class)
                public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
                    return ResponseEntity.status(HttpStatus.NOT_FOUND).body("Resource not found");
                }

                @ExceptionHandler(Exception.class)
                public ResponseEntity<String> handleGeneric(Exception ex) {
                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Something went wrong");
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What is the difference between @ControllerAdvice and @RestControllerAdvice ?

>>  (1) @ControllerAdvice:

        - It is a specialization of @Component used for global exception handling.

        - By default, it returns views (HTML) or ModelAndView, similar to @Controller and to return objects, you need to 
          use @ResponseBody manually.

        Example:

            ```
                @ControllerAdvice
                public class GlobalHandler {

                    // Needed to return JSON
                    @ResponseBody 
                    @ExceptionHandler(Exception.class) 
                    public String handleException(Exception ex) {
                        return "Error occurred";
                    }
                }
            ```
    
    (2) @RestControllerAdvice:

        - It is a combination of @ControllerAdvice + @ResponseBody and used for REST APIs as it returns JSON/XML by default.

        Example:

            ```
                @RestControllerAdvice
                public class RestGlobalHandler {

                    @ExceptionHandler(Exception.class)
                    public String handleException(Exception ex) {
                        return "Error occurred"; // Automatically converted to JSON
                    }
                }
            ```

________________________________________________________________________________________________________________________

*   How do you return consistent error responses from your API ?

>>  To return consistent error responses, create a custom ErrorResponse class and handle all exceptions globally using 
    @RestControllerAdvice and @ExceptionHandler.

________________________________________________________________________________________________________________________

*   What is the difference between @RequestScope, @SessionScope and @ApplicationScope ?

>>  (1) @RequestScope:

        - A bean annotated with @RequestScope is created when a HTTP request is made and destroyed when the request ends.

        - Useful when you need a bean that should not be shared across multiple requests.

        Example:

            ```
                @Component
                @RequestScope
                public class RequestBean {

                }
            ```

    (2) @SessionScope:

        - A bean with @SessionScope is created when the session is established and remains until the session 
          expires or is invalidated.

        - Useful for storing data that should persist across multiple requests but for a specific user session, 
          like login information.

        Example:

            ```
                @Component
                @SessionScope
                public class SessionBean {

                }
            ```

    (3) @ApplicationScope:

        - A bean with @ApplicationScope is created once for the entire application and is destroyed when the 
          application shuts down.

        - Useful for data that should be shared globally across all requests and sessions in the application.

        Example:

            ```
                @Component
                @ApplicationScope
                public class ApplicationBean {

                }
            ```

________________________________________________________________________________________________________________________

*   What is the difference between @Valid and @Validated ?

>>  (1) @Valid:

        - @Valid triggers default validation rules defined using Java Bean Validatio annotations like @NotNull, @Email etc.
        
        - It can be used on method parameters or class fields.

        Example:

            - Validation annotations on a class User only take effect when the object is marked with @Valid.

            ```
                public class User {
                    @NotNull
                    private String name;

                    @Email
                    private String email;
                }
            ```

            ```
                @PostMapping("/register")
                public ResponseEntity<Void> register(@Valid @RequestBody User user) {
                    // Validation happens here
                    return ResponseEntity.ok().build();
                }
            ```
    
    (2) @Validated:

        - @Validated is Spring specific and functions similar to @Valid but is more powerful than @Valid. 
        
        - It allows you to specify groups (e.g., @NotNull(groups = Group1.class)) and trigger validation
          based on the group passed.

        Example:

            - The bean validation annotations which doesn't belong to a group that is passed to @Validated, 
              will have no effect.

            ```
                public class User {
                    @NotNull(groups = First.class)
                    private String name;

                    @Email(groups = Second.class)
                    private String email;
                }
            ```

            ```
                @PostMapping("/register")
                public ResponseEntity<Void> register(@Validated(First.class) @RequestBody User user) {
                    // Only fields validated for 'First' group
                    return ResponseEntity.ok().build();
                }
            ```

________________________________________________________________________________________________________________________

*   What is the use of @EnableWebMvc ?

>>  @EnableWebMvc enables custom Spring MVC configurations, such as view resolvers, message converters etc.

    It registers required MVC beans, such as HttpMessageConverters, RequestMappingHandlerMapping etc.

    When used in a Spring Boot application, it disables Spring Boot’s default MVC auto-configuration, so you must 
    define configurations explicitly.

    Example:

        ```
            @Configuration
            @EnableWebMvc
            public class WebConfig implements WebMvcConfigurer {

                // Manually configure what Spring Boot used to do for you
                @Override
                public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
                    converters.add(new MappingJackson2HttpMessageConverter());
                }

                @Override
                public void addResourceHandlers(ResourceHandlerRegistry registry) {
                    registry
                        .addResourceHandler("/resources/**")
                        .addResourceLocations("/resources/");
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of WebMvcConfigurer ?

>>  WebMvcConfigurer is an interface in Spring that allows you to customize Spring MVC configuration in a non-Spring Boot 
    application. 
    
    It provides a way to define or override the default behavior of Spring MVC components such as Message Converters, 
    View Resolvers, Static Resource Handlers, interceptors etc.

    Example:

        ```
            @Configuration
            @EnableWebMvc  // Enable MVC
            public class WebConfig implements WebMvcConfigurer {

                // Customize message converters (JSON)
                @Override
                public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
                    converters.add(new MappingJackson2HttpMessageConverter());  
                }

                // Add static resource handler (for custom resources)
                @Override
                public void addResourceHandlers(ResourceHandlerRegistry registry) {
                    registry.addResourceHandler("/resources/**")
                            .addResourceLocations("/resources/");
                }

                // Register custom interceptors
                @Override
                public void addInterceptors(InterceptorRegistry registry) {
                        registry.addInterceptor(new CustomInterceptor());
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What is the use of @CrossOrigin ?

>>  The @CrossOrigin annotation in Spring Boot is used to enable CORS at the controller or method level to allow the
    requests from different domains (origins).

    @CrossOrigin applied to a specific controller will enable CORS for only those APIs and not globally accross all the 
    controllers.

    Example:

        ```
            @RestController
            @CrossOrigin(
                origins = "http://localhost:3000", 
                methods = { RequestMethod.GET, RequestMethod.POST },
                allowedHeaders = { "Content-Type", "Authorization" },
                exposedHeaders = { "Custom-Header" },
                allowCredentials = "true",
                maxAge = 3600,
                originPatterns = { "https://*.example.com" }
            )
            public class ProductController {

                @GetMapping("/products")
                public List<Product> getProducts() {
                    return productService.getAll();
                }

                // Or on method-level
                @PostMapping("/products")
                @CrossOrigin(origins = "*", methods = {RequestMethod.POST})
                public void addProduct(@RequestBody Product product) {
                    productService.save(product);
                }
            }
        ```

________________________________________________________________________________________________________________________

*   What are various ways to define CORS in Spring MVC ?

>>  There are 3 main ways to configure CORS in Spring MVC:

    (1) Using @CrossOrigin:

        - Use when you want fine-grained control over CORS per controller or method.

            ```
                @CrossOrigin(origins = "http://localhost:3000")
                @RestController
                public class MyController {
                    
                    @GetMapping("/data")
                    public String getData() {
                        return "Hello";
                    }
                }
            ```

    (2) Global CORS via WebMvcConfigurer:

        - Used to apply CORS rules globally across all Controllers.

            ```
                @Configuration
                public class WebConfig implements WebMvcConfigurer {
                    
                    @Override
                    public void addCorsMappings(CorsRegistry registry) {
                        registry.addMapping("/**")
                                .allowedOrigins("http://localhost:3000")
                                .allowedMethods("GET", "POST", "PUT", "DELETE")
                                .allowedHeaders("*")
                                .exposedHeaders("Authorization")
                                .allowCredentials(true)
                                .maxAge(3600);
                    }
                }
            ```

    (3) Using CorsConfigurationSource Bean (with Spring Security)
        
        - Preferred when you're using Spring Security and want to integrate CORS directly with the security chain.

            ```
                @Bean
                public CorsConfigurationSource corsConfigurationSource() {
                    CorsConfiguration config = new CorsConfiguration();
                    config.setAllowedOrigins(List.of("http://localhost:3000"));
                    config.setAllowedMethods(List.of("GET", "POST"));
                    config.setAllowedHeaders(List.of("*"));
                    config.setAllowCredentials(true);

                    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
                    source.registerCorsConfiguration("/**", config);
                    return source;
                }
            ```

________________________________________________________________________________________________________________________

*   What is the role of DispatcherServlet in Spring MVC ?

>>  The DispatcherServlet acts as the central point for handling all HTTP requests and responses in the Spring MVC framework. 
    
    Key Responsibilities:

        - It receives all incoming HTTP requests and uses HandlerMapping to determine to which controller method request 
          should be forwarded.

        - It binds request parameters to Controller method arguments or model objects.

        - If the response is a view(like "home"), it uses a ViewResolver to map it to an actual view (e.g., JSP, Thymeleaf).

        - It uses HttpMessageConverters to build the HTTP response (JSON, XML, HTML, etc.).

________________________________________________________________________________________________________________________

*   How to configure DispatcherServlet in Spring MVC ?

>>  Follow below steps to configure DispatcherServlet:

        (1) Define DispatcherServlet in web.xml

            ```
                <web-app>

                    <!-- DispatcherServlet registration -->
                    <servlet>
                        <servlet-name>spring</servlet-name> <!-- custom DispatcherServlet name -->
                        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
                        
                        <!-- specify servlet location in case servlet file doen't follow naming convetion-->
                        <init-param>
                            <param-name>contextConfigLocation</param-name>
                            <param-value>/WEB-INF/spring-servlet.xml</param-value>
                        </init-param>
                        <load-on-startup>1</load-on-startup>
                    </servlet>

                    <!-- URL pattern for DispatcherServlet -->
                    <servlet-mapping>
                        <servlet-name>spring</servlet-name>
                        <url-pattern>/</url-pattern>
                    </servlet-mapping>
                </web-app>
            ```
    
        (2) Create the <servlet>.xml file:

            ``
                <beans>

                    <!-- Scan for components -->
                    <context:component-scan base-package="com.example" />

                    <!-- Enable Spring MVC annotations -->
                    <mvc:annotation-driven />

                    <!-- Configure ViewResolver -->
                    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
                        <property name="prefix" value="/WEB-INF/views/" />
                        <property name="suffix" value=".jsp" />
                    </bean>
                </beans>
            ```

________________________________________________________________________________________________________________________

*   Explain the request flow in a Spring MVC application.

>>  (1) The client sends an HTTP request to the server.

    (2) The DispatcherServlet receives the request as the front controller.

    (3) DispatcherServlet uses HandlerMapping to identify the appropriate handler (controller method).

    (4) The HandlerAdapter invokes the identified controller method.

    (5) The controller method processes the request and returns a result (e.g., ModelAndView or response body).

    (6) If a view name is returned, ViewResolver resolves it to a specific view.

    (7) The view is rendered with model data (for MVC) or directly serialized to the response body (for REST).

    (8) The DispatcherServlet sends the final HTTP response back to the client.

________________________________________________________________________________________________________________________

*   What are HandlerMapping, HandlerAdapter, and ViewResolver ?

>>  (1) HandlerMapping:

        - It is responsible for mapping incoming HTTP requests to the appropriate controller methods based on the 
          request URL, HTTP method, and other factors.

    (2) HandlerAdapter:

        - Once HandlerMapping identifies the correct controller method, HandlerAdapter is used to invoke the method.

    (3) ViewResolver:

        - After the controller returns a logical view name, ViewResolver maps it to a specific view (e.g., JSP, Thymeleaf).

________________________________________________________________________________________________________________________

*   How to configure HandlerMapping, HandlerAdapter, and ViewResolver ?

>>  In Spring Boot, you don't need to configure HandlerMapping, HandlerAdapter, or ViewResolver manually because 
    auto-configuration handles it implicitly.

    In a non-Spring Boot Spring MVC application:

        (1) HandlerMapping:

            - HandlerMapping is automatically configured with defaults like RequestMappingHandlerMapping.

        (2) HandlerAdapter:

            - HandlerAdapter is automatically configured with defaults like RequestMappingHandlerAdapter.

        (3) ViewResolver:
            
            - You must explicitly define a ViewResolver bean (e.g., InternalResourceViewResolver for JSP) to resolve view 
              names to actual views.

            - It can be done via Java configuration (@Configuration) or XML configuration (spring-servlet.xml).

                Annotation based:

                    ```
                        @Configuration
                        public class WebConfig implements WebMvcConfigurer {
                            @Override
                            public void configureViewResolvers(ViewResolverRegistry registry) {
                                InternalResourceViewResolver resolver = new InternalResourceViewResolver();
                                resolver.setPrefix("/WEB-INF/views/");
                                resolver.setSuffix(".jsp");
                                registry.viewResolver(resolver);
                            }
                        }
                    ```
                XML based :

                    ```
                        <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
                            <property name="prefix" value="/WEB-INF/views/" />
                            <property name="suffix" value=".jsp" />
                        </bean>
                    ```

________________________________________________________________________________________________________________________

*   Can you map multiple URLs to a single controller method?

>>  Yes, in Spring, you can map multiple URLs to a single controller method using @RequestMapping annotation or its 
    specialized variants like @GetMapping, @PostMapping etc

    Example:

        ```
            @Controller
            public class MyController {

                @RequestMapping(value = {"/home", "/dashboard", "/main"})
                public String handleMultipleUrls() {
                    return "homePage";
                }
            }
        ```

        ```
            @Controller
            public class MyController {

                @GetMapping(value = {"/home", "/dashboard"})
                public String handleGetRequests() {
                    return "homePage";
                }
            }
        ```

________________________________________________________________________________________________________________________

*   How does Spring bind request parameters to Java objects ?

>>  In Spring, request parameters are automatically bound to Java objects using data binding like @ModelAttribute,
    @RequestBody, @RequestParam, @RequestPart, @HeaderAttribute, @SessionAttribute, @RequestAttribute etc   

________________________________________________________________________________________________________________________

*   What is the role of @InitBinder ?

>>  @InitBinder is used to customize how Spring binds HTTP request parameters to Java objects by registering custom 
    editors in a controller.

    It will pre-process the data before binding it to the Java objects.

    Example:

        ```
            @Controller
            public class UserController {

                @InitBinder
                public void initBinder(WebDataBinder binder) {
                    // Trim all string inputs
                    binder.registerCustomEditor(String.class, new StringTrimmerEditor(true));
                }

                @PostMapping("/register")
                public String register(@ModelAttribute User user) {
                    // Custom binding logic applied here
                    return "success";
                }
            }
        ```

________________________________________________________________________________________________________________________

*   How can you manually access HttpServletRequest and HttpServletResponse ?

>>  You can access HttpServletRequest and HttpServletResponse by declaring them as method parameters in controller methods. 
    
    Spring will automatically injects them.

    Example:

        ```
            @GetMapping("/greet")
            public String greet(HttpServletRequest request, HttpServletResponse response) {
                // process
            }
        ```

________________________________________________________________________________________________________________________

*   What are the different ways to deploy a Spring MVC application ?

>>  Follow below steps to deploy a Spring MVC application:
 
        - Package your Spring MVC application as a 'war' (Web Application Archive) file.

            ```
                <packaging>war</packaging>
            ```

        - Add maven war plugin to build .war file.

            ```                
                <build>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-war-plugin</artifactId>
                            <version>3.3.1</version>
                        </plugin>
                    </plugins>
                </build>
            ```

        - Deploy the .war file to a servlet container like Tomcat, Jetty, or JBoss.

        - The container will manage the lifecycle of the application, handling HTTP requests via Spring MVC's DispatcherServlet.

________________________________________________________________________________________________________________________