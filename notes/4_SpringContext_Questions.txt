*   What are various Spring Context annotations ?

>>  Spring 'org.springframework.context.annotation' package provides several annotations for configuring and managing 
    the Spring ApplicationContext:

        (1) @Configuration
        (2) @ComponentScan
        (3) @ComponentScans
        (4) @Bean
        (5) @DependsOn
        (6) @Scope
        (7) @Lazy 
        (8) @Role
        (9) @Primary
        (10) @Profile
        (11) @Conditional
        (12) @Description
        (13) @PropertySource
        (14) @PropertySources
        (15) @ImportResource
        (16) @ImportRuntimeHints
        (17) @ReflectiveScan
        (18) @Fallback
        (19) @EnableMBeanExport
        (20) @EnableLoadTimeWeaving
        (21) @EnableAspectJAutoProxy

________________________________________________________________________________________________________________________

*   Explain @Configuration annotation in detail.

>>  The @Configuration annotation marks a class as a source of bean definitions which is an alternative to the traditional 
    XML-based configuration in Spring.

    It works in conjunction with @ComponentScan, @PropertySource, @Import, etc.

    How @Configuration Works:

        - Spring processes @Configuration classes by reading the @Bean methods and registering the returned objects as 
          Spring-managed beans.

        Example:

            - The AppConfig class is a configuration class.

            - The getMyService method defines a bean of type MyService.

            - Spring will automatically register this bean in the application context.

            ```
                import org.springframework.context.annotation.Bean;
                import org.springframework.context.annotation.Configuration;

                @Configuration
                public class AppConfig {

                    @Bean
                    public MyService getMyService() {
                        return new MyService();
                    }
                }
            ```

    Key Features:

        (a) Works with @Bean:
            
            - Methods inside @Configuration classes can be annotated with @Bean to register Spring beans.

            Example:

                - The dataSource method registers a DataSource bean.

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            public DataSource dataSource() {
                                return new DataSource();
                            }
                        }
                    ```

        (b) Ensures Singleton Behavior:

            - Beans declared in @Configuration classes are singletons by default.
            
            - Spring ensures that the same instance is returned for multiple calls.

            Example:

                - Even if myService() is called multiple times, the same instance is used.

                ```
                    @Configuration
                    public class AppConfig {

                        @Bean
                        public MyService myService() {
                            return new MyService();
                        }
                    }
                ```

        (c) Combines with @ComponentScan:

            - @Configuration can be used with @ComponentScan to automatically scan and register components.

            Example:

                - Scans 'com.example' for @Component, @Service, @Repository, etc.

                ```
                    @Configuration
                    @ComponentScan(basePackages = "com.example")
                    public class AppConfig {
                    }
                ```

        (d) Import Other Configuration Classes:

            - Use @Import to import another configuration class.

            Example:

                - This imports bean definitions from DatabaseConfig

                ```
                    @Configuration
                    @Import(DatabaseConfig.class)
                    public class AppConfig {
                    }
                ```
        (e) Use with @PropertySource:

            - Load external property files.

            Example:

                ```
                    @Configuration
                    @PropertySource("classpath:application.properties")
                    public class AppConfig {
                    }
                ```

        (f) Support for Conditional Beans:

            - Use @Conditional to register beans based on conditions.

            Example:

                ```
                    @Bean
                    @Conditional(DatabaseCondition.class)
                    public DataSource dataSource() {
                        return new DataSource();
                    }
                ```
        (g) Allows Proxy-Based Enhancement (@Configuration vs @Component):

            - @Configuration classes use CGLIB proxies to maintain singleton behavior.
            
            - If you use @Component instead of @Configuration, the singleton guarantee is lost.
            
            Example:

                - myService() is called twice, but Spring ensures only one instance is created.

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            public MyService myService() {
                                return new MyService();
                            }

                            @Bean
                            public AnotherService anotherService() {
                                return new AnotherService(myService()); // Uses the proxy to ensure singleton
                            }
                        }
                    ```

                - If You Use @Component, myService() is called twice, creating two different instances.

                    ```
                        @Component
                        public class AppConfig {

                            @Bean
                            public MyService myService() {
                                return new MyService();
                            }

                            @Bean
                            public AnotherService anotherService() {
                                return new AnotherService(myService()); // Creates a new instance
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @ComponentScan annotation in detail.

>>  The @ComponentScan annotation allows Spring to automatically detect and register beans that are annotated with 
    stereotype annotations such as: @Component, @Service, @Repository, @Controller and @RestController.

    How @ComponentScan Works:

        - When Spring starts up, it looks for classes annotated with component annotations within the specified 
            package and registers them as Spring beans.

        Example:

            - This tells Spring to scan the 'com.example.services' package and register all beans found.

            AppConfig.class:

                ```
                    @Configuration
                    @ComponentScan("com.example.services")
                    public class AppConfig {
                    }
                ```
        
    Key Attributes:

        (a) basePackages: 
        
            - Specifies one or more packages to scan.

            Example:

                - Scans 'com.example.services' and 'com.example.repositories' for beans.

                ```
                    @Configuration
                    @ComponentScan(basePackages = {"com.example.services", "com.example.repositories"})
                    public class AppConfig {
                    }
                ```
        
        (b) basePackageClasses: 
        
            - Alternative to basePackages, it uses class references instead of package names.

            Example:

                ```
                    @Configuration
                    @ComponentScan(basePackageClasses = MyService.class)
                    public class AppConfig {
                    }
                ```
        
        (c) excludeFilters:	
        
            - Excludes specific components from being scanned.

            Example:

                - Excludes components annotated with @Deprecated.

                ```
                    @Configuration
                    @ComponentScan(
                        basePackages = "com.example",
                        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)
                    )
                    public class AppConfig {
                    }
                ```

        (d) includeFilters:	
        
            - Includes specific components for scanning.

            Example:

                - Only scans and registers beans annotated with @Service.

                ```    
                    @Configuration
                    @ComponentScan(
                        basePackages = "com.example",
                        includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Service.class)
                    )
                    public class AppConfig {
                    }
                ```

        (e) lazyInit: 
        
            - If true, beans are lazily initialized instead of eagerly.

________________________________________________________________________________________________________________________

*   Explain @ComponentScans annotation in detail.

>>  The @ComponentScans annotation is a container for multiple @ComponentScan annotations to define multiple separate 
    scanning configurations.

    Example:

        - This scans both 'com.example.service' and 'com.example.repository'

            ```
                @Configuration
                @ComponentScans({
                    @ComponentScan("com.example.service"),
                    @ComponentScan("com.example.repository")
                })
                public class AppConfig {
                }
            ```

        - Instead of using @ComponentScans, one can use below to achieve same result.

            ```
                @Configuration
                @ComponentScan({"com.example.service", "com.example.repository"})
                public class AppConfig {
                }
            ```

________________________________________________________________________________________________________________________

*   Explain @Bean annotation in detail.

>>  The @Bean annotation is used in Spring Context to explicitly declare a bean definition. 

    It is a direct replacement for XML <bean> definitions and works inside @Configuration classes.

    It differs from @Component, which relies on component scanning but @Bean doesn't.

    How @Bean Works:

        - Spring calls the method annotated with @Bean, and the return value is registered as a Spring Bean.

        Example:

            AppConfig.class:

                - The getMyService method creates a bean of type MyService.

                - Spring registers it in the application context.

                ```
                    import org.springframework.context.annotation.Bean;
                    import org.springframework.context.annotation.Configuration;

                    @Configuration
                    public class AppConfig {

                        @Bean
                        public MyService getMyService() {
                            return new MyService();
                        }
                    }
                ```

    Key Features:
    
        (1) Works Inside @Configuration Classes:

            - @Bean should be placed inside a @Configuration class.

            Example:

                AppConfig.class:
                    
                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            public DataSource dataSource() {
                                return new DataSource();
                            }
                        }
                    ```

        (2) Supports Dependency Injection:

            - Beans can depend on other beans, and Spring will automatically resolve dependencies.

            Example:

                - The UserRepository bean depends on DataSource, and Spring injects it if there is a DataSource bean in 
                  the ApplicationContext.
                  
                - In this case, there is a DataSource bean will be created by method dataSource.

                AppConfig.class:
                    
                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            public DataSource dataSource() {
                                return new DataSource();
                            }

                            @Bean
                            public UserRepository userRepository(DataSource dataSource) {
                                return new UserRepository(dataSource);
                            }
                        }
                    ```

        (3) Singleton by Default:

            - Beans are singleton by default, meaning Spring creates only one instance.

            - But you can specify different scopes using @Scope.

            Example:

                - Even if myService() is called multiple times, Spring ensures only one instance is used.

                - But for myDataSource(), a new instance will be created every time the method is called.

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {
                            
                            @Bean
                            public MyService myService() {
                                return new MyService();
                            }

                            @Bean
                            @Scope("prototype")  // Creates a new instance each time
                            public MyDataSource myDataSource() {
                                return new MyDataSource();
                            }
                        }
                    ```
            
        (4️) Supports Custom Initialization and Destruction Methods:

            - @Bean can define methods that should be called during initialization and destruction.

            - @Component doesn't support defining custom Initialization and Destruction methods.

            Example:

                - initMethod="init" sets the method as intializing method which will be called after the bean is created.
                
                - destroyMethod="cleanup" sets the method as destroy method which will be Called before the bean is destroyed.

                DataSource.class:

                    ```    
                        public class DataSource {

                            public DataSource() {
                                System.out.println("DataSource Constructor: Bean Created");
                            }

                            // Initialization logic
                            public void init() {
                                System.out.println("DataSource init(): Initialization logic called");
                            }

                            // Destruction logic
                            public void cleanup() {
                                System.out.println("DataSource cleanup(): Cleanup logic called");
                            }
                        }
                    ```

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {
                            
                            @Bean(initMethod = "init", destroyMethod = "cleanup")
                            public DataSource dataSource() {
                                return new DataSource();
                            }
                        }
                    ```
    
        (5) Supports Conditional Beans:

            - Beans can be conditionally registered using @Conditional.

            Example:

                - This bean is created only if DatabaseCondition is satisfied.

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {
                            
                            @Bean
                            @Conditional(DatabaseCondition.class)
                            public DataSource dataSource() {
                                return new DataSource();
                            }
                        }
                    ```
                
                DatabaseCondition.class:
                
                    ```
                        public class DatabaseCondition implements Condition {

                            @Override
                            public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
                               
                                // Read property "use.database" from application properties
                                String useDatabase = context.getEnvironment().getProperty("use.database");

                                // Return true if property is "true"
                                return "true".equalsIgnoreCase(useDatabase);
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @DependsOn annotation in detail.

>>  The @DependsOn annotation in Spring is used to tell the container that the annotated bean depends on the initialization 
    of one or more other beans.

    It is not for dependency injection, but only for ensuring a specific order of bean initialization.

    How @DependsOn Works:

        - It instructs Spring that a particular bean must be initialized only after other specific beans have been initialized.
        
        - It can be used on class-level beans like @Component, @Service, @Repository, or on @Bean methods inside 
          @Configuration classes.

    Example:

        - The @DependsOn("initBean") on myService() ensures initBean() is created before myService().

        - Here 'initBean' is the name/ID of the bean.

        - If you don’t explicitly name the bean, Spring uses the method name or class name (camelCase) as the default 
          bean name.

        AppConfig.class:

            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    public Initializer initBean() {
                        return new Initializer();
                    }

                    @Bean
                    @DependsOn("initBean")
                    public MyService myService() {
                        return new MyService();
                    }
                }
            ```

    Key Features:

        (1) Works on @Bean Methods and @Component Classes:

            - @DependsOn can be placed on @Bean methods or on class-level annotations like @Component.
            
            Example:

                - On @Bean at the method level.
                
                AppConfig.class:
                    
                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean(name = "setupBean")
                            public SetupBean setupBean() {
                                return new SetupBean();
                            }

                            @Bean
                            @DependsOn("setupBean")
                            public UserService userService() {
                                return new UserService();
                            }
                        }
                    ```

            Example:

                - On @Component at the class level.
                
                - If ProductService doesn’t directly use CacheManager, but you still want to ensure CacheManager is ready first, @DependsOn is the right way.

                CacheManager.class:

                    ```
                        @Component("cacheManager")
                        public class CacheManager {
                            public CacheManager() {
                                System.out.println("CacheManager initialized");
                            }
                        }
                    ```

                ProductService.class:

                    ```
                        @Component
                        @DependsOn("cacheManager")
                        public class ProductService {
                            public ProductService() {
                                System.out.println("ProductService initialized");
                            }
                        }
                    ```

        (2) Can Depend on Multiple Beans:

            - You can define multiple dependencies.

            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            @DependsOn({"beanA", "beanB", "beanC"})
                            public MasterService masterService() {
                                return new MasterService();
                            }
                        }
                    ```
          
        (3) Works in Combination with Other Annotations:

            - Can be combined with @Scope, @Primary, @Lazy, etc.
            
            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            @Scope("prototype")
                            @DependsOn("configBean")
                            public TaskHandler taskHandler() {
                                return new TaskHandler();
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @Scope annotation in detail.

>>  The @Scope annotation in Spring is used to define the scope of a Spring bean, i.e., how and when a new instance of a 
    bean should be created and returned by the Spring container.

    By default, all Spring beans are Singleton scoped, meaning only one instance per Spring container is created.

    With @Scope, we can instruct Spring to create beans in different scopes like prototype, request, session, application, etc.

    How @Scope Works:
        
        - Spring checks the @Scope value and creates beans based on the defined scope.
        
        - It works on @Bean methods inside @Configuration classes as well as Class-level annotations like @Component, 
          @Service, @Repository.

    Example:

        - Each time myService() is accessed, a new instance is returned (because it’s prototype scoped).
        
        AppConfig.class:

            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    @Scope("prototype")
                    public MyService myService() {
                        return new MyService();
                    }
                }
            ```

    Key Features:

        (1) Works with @Bean and @Component:
            
            - You can use @Scope both:

                - on @Bean methods inside @Configuration classes.

                - on @Component classes (or @Service, @Repository).
            
            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            @Scope("prototype")
                            public TaskProcessor taskProcessor() {
                                return new TaskProcessor();
                            }
                        }
                    ```

                EmailSender.class:
                    
                    ```
                        @Component
                        @Scope("prototype")
                        public class EmailSender {
                            // a new instance every time it's requested
                        }
                    ```

        (2) Supported Scopes in Spring (Core & Web):
            
            (a) singleton (default): Single instance for entire container
            (b) prototype: New instance for every request
            (c) request (web only): One instance per HTTP request
            (d) session (web only):	One instance per HTTP session
            (c) application (web only):	One instance per ServletContext
            (d) websocket (web only): One instance per WebSocket session

        (3) Works with Custom Scopes (Advanced):
            
            - Spring allows you to create custom scopes if required.
            
            - You can register a scope with ConfigurableBeanFactory.registerScope().

        (4) Works with Lazy Initialization:

            - You can combine @Scope("prototype") with @Lazy to prevent early bean creation.

            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            @Scope("prototype")
                            @Lazy
                            public ReportGenerator reportGenerator() {
                                return new ReportGenerator();
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @Lazy annotation in detail.

>>  The @Lazy annotation in Spring is used to delay the initialization of a Spring bean until it is actually needed.

    By default, Spring initializes all singleton beans eagerly at the time of ApplicationContext startup, even if they 
    are not yet required. But with @Lazy, Spring will create the bean only when it is first requested.

    For prototype beans, lazy has no effect — prototype beans are already created only on demand.
 
    How @Lazy Works:
        
        - Spring marks the bean as lazily initialized.
        
        - The bean will not be created at startup.
        
        - It will be instantiated only on first access (i.e., getBean() or autowiring).
         
    Example:
        
        AppConfig.class:

            AppConfig.class:

                ```
                    @Configuration
                    public class AppConfig {

                        @Bean
                        @Lazy
                        public ExpensiveService expensiveService() {
                            return new ExpensiveService(); // created only when needed
                        }
                    }
                ```

            ExpensiveService.class:

                ```
                    public class ExpensiveService {
                        public ExpensiveService() {
                            System.out.println("ExpensiveService constructor called!");
                        }
                    }
                ```
            
            Main.class:

                ```
                    // At this point, ExpensiveService is NOT created
                    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                
                    // Now, the bean gets created
                    ExpensiveService service = context.getBean(ExpensiveService.class);
                ```

    Key Features:

        (1) Used on @Autowired injection points:
            
            - You can lazy-load a dependency at the injection point, even if the bean itself is not marked lazy.

            Example:

                - In this case, if UserService bean is not marked as lazy then Spring will create it but here it will be 
                  initialized only when first accessed inside UserController.    

                UserController.class:

                    ```
                        @Component
                        public class UserController {

                            @Autowired
                            @Lazy
                            private UserService userService;
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @Role annotation in detail.

>>  The @Role annotation in Spring is used to assign a role or category to a Spring bean definition, indicating how the 
    bean is intended to be used in the application context.

    It’s mainly used for framework-level metadata tagging, not for bean functionality or business logic.

    Framework author Tag internal infrastructure beans for better documentation.

    How @Role Works:
        
        - Spring internally uses @Role to categorize beans in the BeanDefinition.
        
        - It helps tools or configuration viewers (like Spring IDEs or metadata analyzers) understand the purpose of a bean.
        
        - It does not affect the bean lifecycle or functionality directly.

    @Role Constants:

        - Spring provides three predefined role constants in org.springframework.beans.factory.config.BeanDefinition:

            (a) ROLE_APPLICATION (0) (Default):
            	
                -  Bean is a typical application-level bean, meant for general business logic.
                
            (b) ROLE_SUPPORT (1):

            	- Bean is a supporting bean, often used internally by other application beans.

            (c) ROLE_INFRASTRUCTURE (2):
            	
                - Bean is part of framework infrastructure, like proxies, AOP advisors, message listeners, etc.

    Example:

        - UserService is marked as an application-level bean.

        - AuditHelper is a support bean, used internally.
        
        - MyCustomBeanPostProcessor is a framework infrastructure bean.

        AppConfig.class:
            
            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    @Role(BeanDefinition.ROLE_APPLICATION)
                    public UserService userService() {
                        return new UserService();
                    }

                    @Bean
                    @Role(BeanDefinition.ROLE_SUPPORT)
                    public AuditHelper auditHelper() {
                        return new AuditHelper();
                    }

                    @Bean
                    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
                    public BeanPostProcessor customBeanPostProcessor() {
                        return new MyCustomBeanPostProcessor();
                    }
                }
            ```

________________________________________________________________________________________________________________________

*   Explain @Primary annotation in detail.

>>  The @Primary annotation in Spring is used to mark a bean as the default choice for autowiring when multiple candidates 
    of the same type are available in the Spring container.

    It helps resolve ambiguity in dependency injection when multiple beans of the same type exist.

    Only one bean of a type should be marked @Primary else Spring will throw an error.

    @Primary does not work for collections or maps injection — in those cases, Spring injects all matching beans.

    How @Primary Works:

        - If there are multiple beans of the same type, and Spring doesn’t know which one to inject, it throws an exception.
        
        - When one of them is marked with @Primary, Spring will prefer that bean for autowiring unless another bean is 
          specifically qualified using @Qualifier.

    Example:
        
        - Without using @Primary will throw an ambiguity error: No unique bean of type DataSource found.

        AppConfig.class:

            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    public DataSource mysqlDataSource() {
                        return new MySQLDataSource();
                    }

                    @Bean
                    public DataSource postgresDataSource() {
                        return new PostgresDataSource();
                    }

                    @Bean
                    public UserRepository userRepository(DataSource dataSource) {
                        // Ambiguity: which DataSource to inject?
                        return new UserRepository(dataSource);
                    }
                }
            ```
            
        - When using @Primary, dependencies are resolved automatically even if multiple bean of same type is available.

        AppConfig.class:

            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    @Primary
                    public DataSource mysqlDataSource() {
                        return new MySQLDataSource();
                    }

                    @Bean
                    public DataSource postgresDataSource() {
                        return new PostgresDataSource();
                    }

                    @Bean
                    public UserRepository userRepository(DataSource dataSource) {
                        // mysqlDataSource will be injected automatically
                        return new UserRepository(dataSource);
                    }
                }
            ```

    Key Features:

        (1) Can still override using @Qualifier:

            - Even if a bean is marked @Primary, you can override it with @Qualifier.

            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        public class AppConfig {

                            @Bean
                            @Primary
                            public DataSource mysqlDataSource() {
                                return new MySQLDataSource();
                            }

                            @Bean
                            public DataSource postgresDataSource() {
                                return new PostgresDataSource();
                            }

                            @Bean
                            public UserRepository userRepository(@Qualifier("postgresDataSource") DataSource dataSource) {
                                // Postgres DataSource will be injected because of the @Qualifier
                                return new UserRepository(dataSource);
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @Profile annotation in detail.

>>  The @Profile annotation is used to conditionally enable beans or configuration classes based on the active environment 
    profile.

    It helps in creating environment-specific beans like dev, test, prod, etc., and only loads the relevant beans as per 
    the active profile.

    If no profile is active, then only beans without @Profile annotation are loaded.

    How @Profile Works:

        - You define different beans or configurations with specific @Profile values (like "dev", "prod").
        
        - When the application starts, Spring only loads the beans/configurations that match the currently active profile.
 
    Example:
    
        - Define Beans for Different Profiles.

        - Only one of devDataSource() or prodDataSource() will be registered depending on the active profile.

        DataSourceConfig.class:

            ```
                @Configuration
                public class DataSourceConfig {

                    @Bean
                    @Profile("dev")
                    public DataSource devDataSource() {
                        return new DevDataSource();
                    }

                    @Bean
                    @Profile("prod")
                    public DataSource prodDataSource() {
                        return new ProdDataSource();
                    }
                }
            ```

    How to Activate a Profile:

        (1) Using application.properties or application.yml:

            application.properties
                
                ```
                    spring.profiles.active=dev
                ```

        (2) As a JVM Argument:

            ```
                -Dspring.profiles.active=prod
            ```

        (3) Programmatically:

            Main.class:
                
                ```
                    ConfigurableEnvironment env = context.getEnvironment();
                    env.setActiveProfiles("test");
                ```
    
    Key Features:

        (1) Can be used on @Component or @Service classes:

            ProdEmailService.class:

                ```
                    @Profile("prod")
                    @Service
                    public class ProdEmailService implements EmailService {
                        // Production implementation
                    }
                ```

        (2) Can be used on @Configuration classes:

            DevConfig.class:

                ```
                    @Configuration
                    @Profile("dev")
                    public class DevConfig {
                        // Only loaded in dev profile
                    }
                ```

        (3) Can define multiple profiles for a bean:

            AppConfig.class:

                ```
                    @Configuration
                    public class AppConfig {

                        @Bean
                        @Profile({"dev", "test"})
                        public CacheService cacheService() {
                            return new InMemoryCacheService();
                        }
                    }
                ```

        (4) Can define default profiles:

            application.properties

                ```
                    spring.profiles.default=dev
                ```
    
________________________________________________________________________________________________________________________

*   Explain @Conditional annotation in detail.

>>  The @Conditional allows developers to write custom logic to decide whether a bean or configuration class should be 
    registered in ApplicationContext or not.

    How @Conditional Works:

        - You write a custom class that implements the Condition interface.
        
        - You annotate a @Bean method, @Configuration class, or @Component class with @Conditional(YourCondition.class).
        
        - Spring invokes the matches() method in your Condition class at runtime.

        - If matches() returns true, the bean/config is registered. If false, it's skipped.

    Example:
    
        - Conditionally create Bean Based on Property.

        - If 'use.database=true' in application.properties, the dataSource bean will be created. Otherwise, it will not 
          be registered.

        Condition.class:

            ```
                import org.springframework.context.annotation.Condition;
                import org.springframework.context.annotation.ConditionContext;
                import org.springframework.core.type.AnnotatedTypeMetadata;

                public class DatabaseCondition implements Condition {

                    @Override
                    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
                        String useDatabase = context.getEnvironment().getProperty("use.database");
                        return "true".equalsIgnoreCase(useDatabase);
                    }
                }
            ```

        AppConfig.class:

            ```
                @Configuration
                public class AppConfig {

                    @Bean
                    @Conditional(DatabaseCondition.class)
                    public DataSource dataSource() {
                        return new DataSource();
                    }
                }
            ```

    Key Features:

        (1) Can be used on @Configuration or @Component classes:

            AppConfig.class:
                
                ```
                    @Configuration
                    @Conditional(MyCondition.class)
                    public class AppConfig {
                        // All beans in this config will be included only if condition passes
                    }
                ```

            EmailService.class:
            
                ```
                    @Component
                    @Conditional(MyCondition.class)
                    public class EmailService {
                        // Registered only if condition is met
                    }
                ```

________________________________________________________________________________________________________________________

*   Explain @Description annotation in detail.

>>  The @Description annotation is used to provide a human-readable description for a Spring-managed bean or configuration 
    class.

    It is mainly used for documentation or metadata purposes, so that the Spring context can display the purpose of a 
    bean/configuration class.

    How @Description Works:

        - It stores a text description to a @Bean method or a @Configuration class in the Spring BeanDefinition metadata.
        
        - It does not affect the behavior of the bean — it's purely for documentation and tooling.
        
        - Useful when generating documentation, debugging, or understanding the context configuration more clearly.

    Example:

        AppConfig.class:

            ```
                import org.springframework.context.annotation.Bean;
                import org.springframework.context.annotation.Configuration;
                import org.springframework.context.annotation.Description;

                @Configuration
                public class AppConfig {

                    @Bean
                    @Description("This bean provides core functionality for user authentication service.")
                    public AuthService authService() {
                        return new AuthService();
                    }
                }
            ```

        SecurityConfig.class:
        
            ```
                import org.springframework.context.annotation.Configuration;
                import org.springframework.context.annotation.Description;

                @Configuration
                @Description("Configuration class responsible for setting up security-related beans.")
                public class SecurityConfig {
                    
                    // Beans related to security
                }
            ```

________________________________________________________________________________________________________________________

*   Explain @PropertySource annotation in detail. 

>>  The @PropertySource annotation is used to declare a '.properties' file as a source of configuration values.

    It allows Spring’s Environment abstraction to load and resolve property values (used via @Value, 
    Environment.getProperty(), etc.) from external '.properties' files.

    It only supports '.properties' files and not '.yaml' files — for that use @PropertySourceFactory with custom logic.
    
    Additonally, it cannot override already existing properties unless loaded earlier in the context.

    How @PropertySource Works:

        - It is placed on a @Configuration class.

        - It tells Spring where to find an external properties file and loads it into the Spring Environment.
        
        - The properties can then be injected using @Value or accessed programmatically.
    
    Example:

        application.properties:

            ```
                app.name=MySpringApp
            ```

        AppConfig.class:

            ```
                import org.springframework.context.annotation.Configuration;
                import org.springframework.context.annotation.PropertySource;

                @Configuration
                @PropertySource("classpath:application.properties")
                public class AppConfig {
                    // Spring will load all key-value pairs from application.properties
                }
            ```

        MyService.class:

            ```                
                import org.springframework.beans.factory.annotation.Value;
                import org.springframework.stereotype.Component;

                @Component
                public class MyService {

                    @Value("${app.name}") // Using @Value to Inject Property Values
                    private String appName;

                    public void printAppName() {
                        System.out.println("App Name: " + appName);
                    }
                }
            ```
    
    Key Features:

        (1) Supports loading multiple property files:

            - You can specify multiple property files in a single @PropertySource or use multiple @PropertySource annotations.

            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        @PropertySource({"classpath:db.properties", "classpath:application.properties"})
                        public class AppConfig {
                            // Both property files are loaded into the Environment
                        }
                    ```

        (2) Supports loading properties from external file system locations:

            - Property files can also be loaded from external locations, outside the classpath.
            
            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        @PropertySource("file:/opt/config/custom.properties")
                        public class AppConfig {
                            // Loads custom.properties from absolute path
                        }
                    ```

        (3) Supports optional loading using ignoreResourceNotFound=true:

            - If a property file is not guaranteed to be present, you can prevent errors using ignoreResourceNotFound.
                
            Example:    

                AppConfig.class:

                    ```
                        @Configuration
                        @PropertySource(value = "classpath:optional.properties", ignoreResourceNotFound = true)
                        public class AppConfig {
                            // If optional.properties doesn't exist, Spring won't fail
                        }
                    ```

        (4) Properties become accessible via Environment API:

            - The loaded properties can also be accessed programmatically using Spring’s Environment interface.

            Example:

                AppConfig.class:

                    ```
                        @Configuration
                        @PropertySource("classpath:application.properties")
                        public class AppConfig implements EnvironmentAware {

                            private Environment env;

                            @Override
                            public void setEnvironment(Environment environment) {
                                this.env = environment;
                            }

                            @PostConstruct
                            public void printAppInfo() {
                                System.out.println("App Name: " + env.getProperty("app.name"));
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @PropertySources annotation in detail. 

>>  The @PropertySources annotation is used to declare multiple @PropertySource annotations in a single place. 
 
    Instead of writing multiple @PropertySource annotations separately, you can group them inside @PropertySources.

    Rest of the features are similar to @PropertySource.

    How @PropertySources Works:
        
        - When the Spring container starts and processes a class annotated with @Configuration, it evaluates all 
          @PropertySource annotations inside @PropertySources.

        - Each property file specified is loaded into the Environment, making the properties available for Spring Application. 

        - If a key is repeated across files, the last loaded file overrides earlier values.
    
    Example:

        AppConfig.class:

            ```
                @Configuration
                @PropertySources({
                    @PropertySource("classpath:db.properties"),
                    @PropertySource("classpath:application.properties")
                })
                public class AppConfig {
                    // Both db.properties and application.properties are loaded
                }
            ```

            - This is equivalent to:

            ```
                @Configuration
                @PropertySource("classpath:db.properties")
                @PropertySource("classpath:application.properties")
                public class AppConfig {
                }
            ```

    Key Features:
       
        (1) Works on @Configuration classes
            
            - @PropertySources can only be used on @Configuration classes, ensuring that property files are loaded during 
              context initialization.
        
________________________________________________________________________________________________________________________

*   Explain @ImportResource annotation in detail. 

>>  The @ImportResource is used to import traditional Spring XML configuration files into a Java-based configuration context.

    This annotation allows Spring to load bean definitions from XML files alongside Java-based @Configuration classes.

    It is extremely useful when migrating legacy applications from XML-based Spring configuration to Java-based 
    configuration, allowing coexistence of both.

    Key Features:

        (1) Allows mixing XML-based and Java-based configuration
            
            application-context.xml:

                ```
                    <beans xmlns="http://www.springframework.org/schema/beans"
                        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                        xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans.xsd">

                        <bean id="myService" class="com.example.MyService"/>
                    </beans>
                ```

            AppConfig.java:

                ```
                    @Configuration
                    @ImportResource("classpath:application-context.xml")
                    public class AppConfig {
                        // Beans from application-context.xml will be registered in Spring context
                    }
                ```
            
        (2) Supports Multiple XML Configuration Files:

            application-context.xml:

                ```
                    <bean id="myService" class="com.example.MyService"/>
                ```

            database-config.xml
                    
                ```
                    <bean id="dbService" class="com.example.DatabaseService"/>
                ```

            AppConfig.java

                ```
                    @Configuration
                    @ImportResource({
                        "classpath:application-context.xml",
                        "classpath:database-config.xml"
                    })
                    public class AppConfig { }
                ```

            Main.java

                ```
                    import org.springframework.context.ApplicationContext;
                    import org.springframework.context.annotation.AnnotationConfigApplicationContext;

                    public class Main {
                        public static void main(String[] args) {
                            ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                            DatabaseService db = context.getBean(DatabaseService.class);
                            db.connect();
                        }
                    }
                ```

        (3) Supports File Paths: classpath, file system, relative
                
                AppConfig.java

                    ```
                        @Configuration
                        @ImportResource({
                            "classpath:application-context.xml",
                            "file:/opt/config/external-config.xml"
                        })
                        public class AppConfig { }
                    ```

                external-config.xml
                    
                    ```
                        <bean id="externalService" class="com.example.ExternalService"/>
                    ```

                Main.java

                    ```
                        import org.springframework.context.ApplicationContext;
                        import org.springframework.context.annotation.AnnotationConfigApplicationContext;

                        public class Main {
                            public static void main(String[] args) {
                                ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                                ExternalService service = context.getBean(ExternalService.class);
                                service.run();
                            }
                        }
                    ```

________________________________________________________________________________________________________________________

*   Explain @ImportRuntimeHints annotation in detail. 

>>  The @ImportRuntimeHints is used for Ahead-of-Time (AOT) processing and native image generation, especially when 
    using GraalVM.

    It helps register runtime hints (like reflection, resource access, serialization, etc.) that are required at runtime, 
    especially in native image environments, where such dynamic behavior is not automatically available.

    When using native compilation (GraalVM), reflection and other runtime behaviors must be explicitly registered.
    @ImportRuntimeHints allows developers to register such requirements declaratively using a RuntimeHintsRegistrar.

    Key Features:
            
        (1) Used to Import Runtime Hints via RuntimeHintsRegistrar
            
            MyHintsRegistrar.java:

                ```
                    import org.springframework.aot.hint.RuntimeHints;
                    import org.springframework.aot.hint.RuntimeHintsRegistrar;
                    import org.springframework.aot.hint.TypeReference;

                    public class MyHintsRegistrar implements RuntimeHintsRegistrar {

                        @Override
                        public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
                            hints.reflection().registerType(TypeReference.of(MyService.class), 
                                hint -> hint.withMembers());
                        }
                    }
                ```

            AppConfig.java:

                    import org.springframework.context.annotation.Configuration;
                    import org.springframework.aot.hint.annotation.ImportRuntimeHints;

                    @Configuration
                    @ImportRuntimeHints(MyHintsRegistrar.class)
                    public class AppConfig { }

            
            Main.java:

                ```
                    import org.springframework.context.ApplicationContext;
                    import org.springframework.context.annotation.AnnotationConfigApplicationContext;

                    public class Main {
                        public static void main(String[] args) {
                            ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                            MyService service = context.getBean(MyService.class);  // Works fine in native image
                            service.process();
                        }
                    }
                ```

        (2) Supports Multiple Hints Registrars
            
            AppConfig.java:

                ```
                    import org.springframework.context.annotation.Configuration;
                    import org.springframework.aot.hint.annotation.ImportRuntimeHints;

                    @Configuration
                    @ImportRuntimeHints({MyHintsRegistrar.class, AnotherHintsRegistrar.class})
                    public class AppConfig { }
                ```

            Main.java:

                ```
                    import org.springframework.context.ApplicationContext;
                    import org.springframework.context.annotation.AnnotationConfigApplicationContext;

                    public class Main {
                        public static void main(String[] args) {
                            ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                            
                            MyService myService = context.getBean(MyService.class);
                            myService.process();

                            AnotherService anotherService = context.getBean(AnotherService.class);
                            anotherService.doWork();
                        }
                    }
                ```

________________________________________________________________________________________________________________________    

*   Explain @ReflectiveScan annotation in detail. 

>>  It tells Spring that a particular class should be scanned for reflection metadata at build time, which is required 
    in environments where reflection metadata is not automatically preserved, like AOT (Ahead-of-Time) or native image 
    compilations.

    This annotation is especially useful when you need certain classes to be available for reflection-based operations 
    in native image runtime (like invoking constructors, accessing fields, calling methods, etc.), and Spring doesn’t 
    automatically detect them.

    How @ReflectiveScan Works:

        - When Spring performs AOT processing (such as native image generation), it scans for this annotation and ensures 
          that reflective metadata for the annotated class is registered in the native image configuration.   

    Key Features:

        (a) Helps Enable Reflection for Native Images:

            - The MyModel class will be registered for reflection in native image builds.
                        
            MyModel.class:
                
                ```
                    import org.springframework.context.annotation.ReflectiveScan;

                    @ReflectiveScan
                    public class MyModel {
                        private String name;

                        public MyModel() {}

                        public String getName() {
                            return name;
                        }

                        public void setName(String name) {
                            this.name = name;
                        }
                    }
                ```

            - Registers classes so that constructors, methods, and fields are accessible reflectively in native image runtimes.
                
            Main.java

                ```
                    public class Main {
                        public static void main(String[] args) throws Exception {
                            Class<?> clazz = Class.forName("com.example.MyModel");
                            Object obj = clazz.getDeclaredConstructor().newInstance();
                            System.out.println("Instance created via reflection: " + obj);
                        }
                    }
                ```

________________________________________________________________________________________________________________________

*   Explain @Fallback annotation in detail. 

>>  The @Fallback annotation is used to define a fallback mechanism for method invocations, typically in fault-tolerant 
    systems. 
    
    It allows developers to specify an alternative method or handler class to be called when the primary method fails, 
    such as during an exception, timeout, or circuit breaker open state.

    How @Fallback Works:

        - When the primary business method throws an exception, times out, or fails due to resilience configuration, 
          control is automatically passed to the fallback method or class defined using @Fallback.

        - The fallback method should have the same signature (input parameters and return type) as the original method.

    Example: 

        - If greet("fail") is called, the fallbackGreet method will be invoked instead of failing the service.

        ```
            import org.eclipse.microprofile.faulttolerance.Fallback;
            import javax.enterprise.context.ApplicationScoped;

            public class GreetingService {

                @Fallback(fallbackMethod = "fallbackGreet")
                public String greet(String name) {
                    if (name.equals("fail")) {
                        throw new RuntimeException("Simulated failure");
                    }
                    return "Hello, " + name;
                }

                public String fallbackGreet(String name) {
                    return "Hello from fallback, " + name;
                }
            }
        ```
    Key Features:

        (a) Supports Fallback Handler Classes:

            - You can also define a separate FallbackHandler class by implementing the FallbackHandler<T> interface.

            Operation.class:

                ```
                    import org.eclipse.microprofile.faulttolerance.Fallback;
                    import org.eclipse.microprofile.faulttolerance.FallbackHandler;

                    public class Operation {

                        @Fallback(MyFallbackHandler.class)
                        public String riskyOperation() {
                            throw new RuntimeException("Failed");
                        }
                    }
                ```

            MyFallbackHandler.class:

                ```
                    public class MyFallbackHandler implements FallbackHandler<String> {

                        @Override
                        public String handle(ExecutionContext context) {
                            return "Handled by fallback handler";
                        }
                    }
                ```

________________________________________________________________________________________________________________________

*   Explain @EnableAspectJAutoProxy annotation in detail.  

>>  The @EnableAspectJAutoProxy annotation is used in Spring AOP (Aspect-Oriented Programming) to enable support for 
    AspectJ-style method interception. 
    
    It allows Spring to create proxy objects for beans annotated with @Aspect, enabling method interception and execution 
    of cross-cutting concerns like logging, security, and transaction management.

    How @EnableAspectJAutoProxy Works:

        - When applied to a Spring configuration class, it enables proxy-based AOP for aspects defined using @Aspect annotations.
        
        - Spring automatically wraps beans with proxies to intercept method calls and apply advice (e.g., @Before, @After).
        
        - It supports two proxying mechanisms:
            
            - JDK Dynamic Proxy (default) – Used when the target class implements interfaces.
            - CGLIB Proxy (if proxyTargetClass = true) – Used for proxying classes without interfaces.
    
    Example:

        - Define the Target Service

            MyService.class:

                ```
                    import org.springframework.stereotype.Service;

                    @Service
                    public class MyService {

                        public void performTask() {
                            System.out.println("Executing service method...");
                        }
                    }
                ```

        - Define an Aspect with Advice

            - The @Before advice from LoggingAspect executes before performTask() of MyService class.
            
            - Spring automatically proxies MyService, allowing method interception.

            LoggingAspect.class:

                ```
                    import org.aspectj.lang.annotation.Aspect;
                    import org.aspectj.lang.annotation.Before;
                    import org.springframework.stereotype.Component;

                    @Aspect
                    @Component
                    public class LoggingAspect {

                        @Before("execution(* com.example.service.*.*(..))")
                        public void logBeforeMethod() {
                            System.out.println("Logging before method execution...");
                        }
                    }
                ```

        - Enable AOP in Configuration

            AppConfig.class:

                ```
                    import org.springframework.context.annotation.Bean;
                    import org.springframework.context.annotation.ComponentScan;
                    import org.springframework.context.annotation.Configuration;
                    import org.springframework.context.annotation.EnableAspectJAutoProxy;

                    @Configuration
                    @EnableAspectJAutoProxy // Enables proxy-based AOP
                    @ComponentScan(basePackages = "com.example")
                    public class AppConfig {

                        @Bean
                        public MyService myService() {
                            return new MyService();
                        }
                    }
                ```

        - Run the Application

            Main.class:

                ```
                    import org.springframework.context.ApplicationContext;
                    import org.springframework.context.annotation.AnnotationConfigApplicationContext;

                    public class Main {
                        public static void main(String[] args) {
                            ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
                            MyService service = context.getBean(MyService.class);
                            service.performTask();
                        }
                    }
                ```

        - Output:

            ```
                Logging before method execution...
                Executing service method...
            ```

________________________________________________________________________________________________________________________







